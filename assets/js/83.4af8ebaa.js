(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{548:function(e,t,a){"use strict";a.r(t);var r=a(2),o=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p"),t("div",{staticClass:"table-of-contents"},[t("ul",[t("li",[t("a",{attrs:{href:"#ios-ipc-线程通信"}},[e._v("iOS IPC 线程通信")]),t("ul",[t("li",[t("a",{attrs:{href:"#performselector-onthread"}},[e._v("performSelector:onThread")])]),t("li",[t("a",{attrs:{href:"#nsmachport"}},[e._v("NSMachPort")])]),t("li",[t("a",{attrs:{href:"#gcd"}},[e._v("GCD")])])])])])]),t("p"),e._v(" "),t("p",[e._v("[TOC]")]),e._v(" "),t("h1",{attrs:{id:"ios-ipc-线程通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ios-ipc-线程通信"}},[e._v("#")]),e._v(" iOS IPC 线程通信")]),e._v(" "),t("p",[e._v("在iOS中 线程通信有两种方式：")]),e._v(" "),t("ul",[t("li",[e._v("performSelector:onThread")]),e._v(" "),t("li",[e._v("NSMachPort")]),e._v(" "),t("li",[e._v("GCD")])]),e._v(" "),t("h3",{attrs:{id:"performselector-onthread"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#performselector-onthread"}},[e._v("#")]),e._v(" "),t("strong",[e._v("performSelector:onThread")])]),e._v(" "),t("div",{staticClass:"language-objective-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n//在指定线程调用\n[self performSelector:@selector(sendMessage) onThread:thread_1 withObject:nil waitUntilDone:YES];\n\n//在主线程调用\n[self performSelectorOnMainThread:@selector(sendMessage) withObject:nil waitUntilDone:YES];\n\n")])])]),t("p",[t("code",[e._v("performSelector")]),e._v(" 系列是比较常用的线程通信的方法，不过注意该系列方法依赖于 "),t("code",[e._v("Runloop")]),e._v("，主线程的"),t("code",[e._v("Runloop")]),e._v("是自动创建的，但是子线程需要手动运行"),t("code",[e._v("Runloop")]),e._v("。")]),e._v(" "),t("h3",{attrs:{id:"nsmachport"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nsmachport"}},[e._v("#")]),e._v(" "),t("strong",[e._v("NSMachPort")])]),e._v(" "),t("div",{staticClass:"language-objective-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('@interface IPCTest ()\n<NSMachPortDelegate>\n{\n    NSThread *thread_1;\n    NSMachPort *machPort_1;\n    \n    NSThread *thread_2;\n    NSMachPort *machPort_2;\n}\n\n@end\n\n@implementation IPCTest\n\n- (instancetype)init{\n    self = [super init];\n    if (self) {\n        [self loadDefaultData];\n    }\n    return self;\n}\n\n- (void)loadDefaultData{\n    thread_1 = [[NSThread alloc] initWithTarget:self selector:@selector(startRunloop_1) object:nil];\n    [thread_1 setName:@"thread_1"];\n    \n    thread_2 = [[NSThread alloc] initWithTarget:self selector:@selector(startRunloop_2) object:nil];\n    [thread_2 setName:@"thread_2"];\n    \n    \n    machPort_1 = (NSMachPort *)[NSMachPort port];\n    machPort_2 = (NSMachPort *)[NSMachPort port];\n    \n    //注册delegate\n    machPort_2.delegate = self;\n    \n    [thread_1 start];\n    [thread_2 start];\n}\n\n- (void)startRunloop_1{\n    [[NSRunLoop currentRunLoop] addPort:machPort_1 forMode:NSDefaultRunLoopMode];\n    [[NSRunLoop currentRunLoop] run];\n}\n\n- (void)startRunloop_2{\n    //port 加入runloop\n    [[NSRunLoop currentRunLoop] addPort:machPort_2 forMode:NSDefaultRunLoopMode];\n    [[NSRunLoop currentRunLoop] run];\n}\n\n- (void)sendMessage{\n    NSMutableArray *array = [NSMutableArray arrayWithObjects:@"12",@"23",@"34", nil];\n    NSData *data = [NSKeyedArchiver archivedDataWithRootObject:array];\n    NSMutableArray *dataArray = [NSMutableArray arrayWithObject:data];\n    \n    //线程1 里用 machPort_2 往 线程2发消息,注意这里 components 里的参数必须是一系列data数据（或 NSPort）,所以要用 NSKeyedArchiver 生成 data\n    [machPort_2 sendBeforeDate:[NSDate date] msgid:123456 components:dataArray from:machPort_1 reserved:0];\n}\n\n\n#pragma mark - Public\n- (void)invokeIPC{\n    [self performSelector:@selector(sendMessage) onThread:thread_1 withObject:nil waitUntilDone:YES];\n}\n\n\n#pragma mark - NSPortDelegate\n/*\n 这里注意实现的是 NSPortDelegate （- (void)handlePortMessage:(NSPortMessage *)message;） 的方法，而不是 NSMachPortDelegate （- (void)handleMachMessage:(void *)msg;）\n NSMachPortDelegate 的方法参数是不透明结构 void *，所以调用了 NSPortDelegate 的方法，但是由于 NSPortMessage * 也是不透明的，看不到类内部定义，且无法使用 valueForKey方法，因此机制的我把 NSPortMessage * 改成了 id\n */\n- (void)handlePortMessage:(id)message{\n    NSLog(@"%@",message);\n    NSMutableArray *dataArray = [message valueForKey:@"components"];\n    NSMutableArray *array = [NSKeyedUnarchiver unarchiveObjectWithData:[dataArray lastObject]];\n    NSLog(@"%@",array);\n}\n\n@end\n')])])]),t("p",[e._v("NSPort有3个子类，NSSocketPort、NSMessagePort、NSMachPort，但在iOS下只有NSMachPort可用。使用的方式为接收线程中注册NSMachPort，在另外的线程中使用此port发送消息，则被注册线程会收到相应消息，然后最终在主线程里调用某个回调函数。")]),e._v(" "),t("p",[e._v("基本上能用 NSPort 的地方都可以用 performSelector 来代替，所以用 NSPort 的地方比较少。")]),e._v(" "),t("p",[e._v("上面Demo中有几个注意点：")]),e._v(" "),t("ul",[t("li",[e._v("Port必须加入对应线程的Runloop")]),e._v(" "),t("li",[e._v("sendBeforeDate 中的 components 参数必须由 NSData 或 NSPort类型，不能由其他类型，否则参数会传递不过去")]),e._v(" "),t("li",[e._v("NSMachPortDelegate 的方法参数是不透明结构 "),t("code",[e._v("void *")]),e._v("，所以调用了 NSPortDelegate 的方法，但是由于 "),t("code",[e._v("NSPortMessage *")]),e._v(" 也是不透明的，看不到类内部定义，且无法使用 valueForKey方法，因此可以把 "),t("code",[e._v("NSPortMessage *")]),e._v("改为 "),t("code",[e._v("id")]),e._v(" 类型")])]),e._v(" "),t("h3",{attrs:{id:"gcd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gcd"}},[e._v("#")]),e._v(" "),t("strong",[e._v("GCD")])]),e._v(" "),t("div",{staticClass:"language-objective-c extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    dispatch_async(dispatch_get_main_queue(), ^{\n        [self sendMessage];\n    });\n")])])])])}),[],!1,null,null,null);t.default=o.exports}}]);