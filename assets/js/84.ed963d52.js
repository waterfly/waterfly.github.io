(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{547:function(e,n,t){"use strict";t.r(n);var s=t(2),_=Object(s.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p"),n("div",{staticClass:"table-of-contents"},[n("ul")]),n("p"),e._v(" "),n("p",[e._v("今天重温了 《Effective Objective-C 2.0》，里面有一个章节 "),n("strong",[e._v("多用派发队列，少用同步锁")]),e._v(" 以前被忽视了，写出来备份下，以下内容为该章节内容抄录和总结。")]),e._v(" "),n("p",[e._v("在Objective-C中，如果有多个线程要执行同一份代码，那么有时可能会出问题，这种情况一般有三种办法：")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("同步块")]),e._v(" "),n("div",{staticClass:"language-objective-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    @synchronized (self) {\n    }\n")])])])]),e._v(" "),n("li",[n("p",[e._v("使用 NSLock 或 NSRecursiveLock 等锁对象")])]),e._v(" "),n("li",[n("p",[e._v("使用GCD")])])]),e._v(" "),n("p",[e._v("相对来说，GCD更加简单而高效。")]),e._v(" "),n("p",[e._v("举个例子，要保证对某一个属性的线程安全，此时使用GCD有两种做法")]),e._v(" "),n("p",[n("strong",[e._v("使用串行队列")])]),e._v(" "),n("div",{staticClass:"language-objective-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('_syncqueue = dispatch_queue_create("com.test.gcd", NULL);\n\n- (NSString *)something{\n    __block NSString *localSomething = nil;\n    dispatch_sync(_syncqueue, ^{\n        localSomething = _something;\n    });\n    return localSomething;\n}\n\n- (void)setSomething:(NSString *)something{\n    dispatch_sync(_syncqueue, ^{\n        _something = something;\n    });\n}\n')])])]),n("p",[e._v("此模式把设置操作和读取操作都放到串行队列里执行，所有对属性的访问就都同步了。")]),e._v(" "),n("p",[n("strong",[e._v("使用并行队列")])]),e._v(" "),n("p",[e._v("其实，对于属性来说，多个get方法是可以并发执行的，而get方法和set方法之间不能并发执行。而且set方法可以是异步的，因为set方法不需要返回值。")]),e._v(" "),n("p",[e._v("按照这个思路，把队列改成并行队列，，并使用 "),n("code",[e._v("dispatch_barrier_async")]),e._v(" 函数，使 get 方法和 set方法 不并发执行。")]),e._v(" "),n("div",{staticClass:"language-objective-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("_syncqueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);\n\n- (NSString *)something{\n    __block NSString *localSomething = nil;\n    dispatch_sync(_syncqueue, ^{\n        localSomething = _something;\n    });\n    return localSomething;\n}\n\n- (void)setSomething:(NSString *)something{\n    dispatch_barrier_async(_syncqueue, ^{\n        _something = something;\n    });\n}\n")])])]),n("p",[e._v("由于set方法中使用了栅栏块，一旦有写入操作时，就会等所有读取的操作全部执行完才会执行写入操作。")]),e._v(" "),n("p",[e._v("同时注意set方法 "),n("code",[e._v("dispatch_barrier_async")]),e._v("为异步，因为set方法不需要同步，从调用者的角度来讲使用异步会加快执行速度。但是这么做有一个坏处："),n("strong",[e._v("执行异步派发时，需要拷贝块，如果拷贝快的时间明显超过执行快的所花的时间，则这种做法比使用同步会更慢，但是如果块要执行的为更繁重的任务，那么可以考虑使用异步。对于本文中的例子，只是简单的set，则不需要使用异步派发。")])]),e._v(" "),n("p",[e._v("不过这个示例还有点问题，因为使用了全局并发队列，可能会阻塞系统的队列，所以最好使用自定义并发队列。")]),e._v(" "),n("div",{staticClass:"language-objective-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('_syncqueue = dispatch_queue_create("com.test.concurrent", DISPATCH_QUEUE_CONCURRENT);\n\n- (NSString *)something{\n    __block NSString *localSomething = nil;\n    dispatch_sync(_syncqueue, ^{\n        localSomething = _something;\n    });\n    return localSomething;\n}\n\n- (void)setSomething:(NSString *)something{\n    dispatch_barrier_async(_syncqueue, ^{\n        _something = something;\n    });\n}\n')])])])])}),[],!1,null,null,null);n.default=_.exports}}]);