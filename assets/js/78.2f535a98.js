(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{546:function(t,a,e){"use strict";e.r(a);var r=e(2),s=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#条件语句"}},[t._v("条件语句")]),a("ul",[a("li",[a("a",{attrs:{href:"#尤达表达式"}},[t._v("尤达表达式")])]),a("li",[a("a",{attrs:{href:"#nil-和-bool"}},[t._v("nil 和 BOOL")])]),a("li",[a("a",{attrs:{href:"#黄金大道"}},[t._v("黄金大道")])]),a("li",[a("a",{attrs:{href:"#复杂的表达式"}},[t._v("复杂的表达式")])]),a("li",[a("a",{attrs:{href:"#三元运算符"}},[t._v("三元运算符")])]),a("li",[a("a",{attrs:{href:"#错误处理"}},[t._v("错误处理")])])])]),a("li",[a("a",{attrs:{href:"#case语句"}},[t._v("Case语句")])]),a("li",[a("a",{attrs:{href:"#命名"}},[t._v("命名")]),a("ul",[a("li",[a("a",{attrs:{href:"#通用的约定"}},[t._v("通用的约定")])]),a("li",[a("a",{attrs:{href:"#常量"}},[t._v("常量")])]),a("li",[a("a",{attrs:{href:"#方法"}},[t._v("方法")])]),a("li",[a("a",{attrs:{href:"#字面值"}},[t._v("字面值")])])])]),a("li",[a("a",{attrs:{href:"#类"}},[t._v("类")]),a("ul",[a("li",[a("a",{attrs:{href:"#类名"}},[t._v("类名")])]),a("li",[a("a",{attrs:{href:"#initializer-和-dealloc"}},[t._v("Initializer 和 dealloc")])]),a("li",[a("a",{attrs:{href:"#designated-和-secondary-初始化方法"}},[t._v("Designated 和 Secondary 初始化方法")])]),a("li",[a("a",{attrs:{href:"#属性"}},[t._v("属性")])]),a("li",[a("a",{attrs:{href:"#方法"}},[t._v("方法")])]),a("li",[a("a",{attrs:{href:"#相等性"}},[t._v("相等性")])])])]),a("li",[a("a",{attrs:{href:"#categories"}},[t._v("Categories")])]),a("li",[a("a",{attrs:{href:"#protocols"}},[t._v("Protocols")])]),a("li",[a("a",{attrs:{href:"#nsnotification"}},[t._v("NSNotification")])]),a("li",[a("a",{attrs:{href:"#美化代码"}},[t._v("美化代码")])]),a("li",[a("a",{attrs:{href:"#代码组织"}},[t._v("代码组织")])]),a("li",[a("a",{attrs:{href:"#对象间的通讯"}},[t._v("对象间的通讯")])]),a("li",[a("a",{attrs:{href:"#面向切面编程"}},[t._v("面向切面编程")])])])]),a("p"),t._v(" "),a("p",[t._v("[TOC]")]),t._v(" "),a("p",[t._v("原文："),a("a",{attrs:{href:"https://github.com/oa414/objc-zen-book-cn#%E9%BB%84%E9%87%91%E5%A4%A7%E9%81%93",target:"_blank",rel:"noopener noreferrer"}},[t._v("禅与 Objective-C 编程艺术"),a("OutboundLink")],1)]),t._v(" "),a("h1",{attrs:{id:"条件语句"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#条件语句"}},[t._v("#")]),t._v(" 条件语句")]),t._v(" "),a("p",[t._v("总是要用大括号")]),t._v(" "),a("h2",{attrs:{id:"尤达表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#尤达表达式"}},[t._v("#")]),t._v(" 尤达表达式")]),t._v(" "),a("p",[t._v("不推荐")]),t._v(" "),a("h2",{attrs:{id:"nil-和-bool"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nil-和-bool"}},[t._v("#")]),t._v(" nil 和 BOOL")]),t._v(" "),a("p",[t._v("不要直接把对象跟nil或YES,NO比较，用 if(!xx)来即可")]),t._v(" "),a("h2",{attrs:{id:"黄金大道"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#黄金大道"}},[t._v("#")]),t._v(" 黄金大道")]),t._v(" "),a("p",[t._v("即不要嵌套"),a("code",[t._v("if")]),t._v("语句，可以使用"),a("code",[t._v("return")]),t._v("语句避免增加循环的复杂度")]),t._v(" "),a("p",[t._v("即推荐：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("- (void)someMethod {\n  if (![someOther boolValue]) {\n      return;\n  }\n\n  //Do something important\n}\n")])])]),a("p",[t._v("不推荐")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("- (void)someMethod {\n  if ([someOther boolValue]) {\n    //Do something important\n  }\n}\n")])])]),a("p",[t._v("其中有句原话是：")]),t._v(" "),a("blockquote",[a("p",[t._v("在使用条件语句编程时，代码的左边距应该是一条“黄金”或者“快乐”的大道。")])]),t._v(" "),a("p",[t._v("对黄金大道这个比喻不理解，不明白黄金大道的在这里的比喻。\n但是上面的例子是比较清晰的。")]),t._v(" "),a("h2",{attrs:{id:"复杂的表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复杂的表达式"}},[t._v("#")]),t._v(" 复杂的表达式")]),t._v(" "),a("p",[t._v("if中的复杂表达式，提取出来赋值给BOOL，使之更清晰 。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('BOOL nameContainsSwift  = [sessionName containsString:@"Swift"];\nBOOL isCurrentYear      = [sessionDateCompontents year] == 2014;\nBOOL isSwiftSession     = nameContainsSwift && isCurrentYear;\n\nif (isSwiftSession) {\n    // Do something very cool\n}\n')])])]),a("h2",{attrs:{id:"三元运算符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三元运算符"}},[t._v("#")]),t._v(" 三元运算符")]),t._v(" "),a("p",[t._v("三元运算符里的子句，应该也只是求值后的变量，不要直接用复杂的句子。")]),t._v(" "),a("p",[t._v("推荐")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("result = a > b ? x : y;\n")])])]),a("p",[t._v("不推荐")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("result = a > b ? x = c > d ? c : d : y;\n")])])]),a("p",[t._v("另外，推荐更灵活地表达方式：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("result = object ? : [self createObject];\n")])])]),a("p",[t._v("不推荐")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("result = object ? object : [self createObject];\n")])])]),a("h2",{attrs:{id:"错误处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#错误处理"}},[t._v("#")]),t._v(" 错误处理")]),t._v(" "),a("blockquote",[a("p",[t._v("有些方法通过参数返回 error 的引用，使用这样的方法时应当检查方法的返回值，而非 error 的引用。")]),t._v(" "),a("p",[t._v("推荐:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("  NSError *error = nil;\n  if (![self trySomethingWithError:&error]) {\n      // Handle Error\n  }\n")])])]),a("p",[t._v("此外，一些苹果的 API 在成功的情况下会对 error 参数（如果它非 NULL）写入垃圾值（garbage values），所以如果检查 error 的值可能导致错误 （甚至崩溃）。")])]),t._v(" "),a("h1",{attrs:{id:"case语句"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#case语句"}},[t._v("#")]),t._v(" Case语句")]),t._v(" "),a("p",[t._v("switch语句里是枚举变量时，建议不要用"),a("code",[t._v("default")]),t._v(",因为当枚举增加时，这些switch语句会收到警告")]),t._v(" "),a("p",[t._v("使用枚举变量时，建议使用新的宏"),a("code",[t._v("- NS_ENUM()")])]),t._v(" "),a("h1",{attrs:{id:"命名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命名"}},[t._v("#")]),t._v(" 命名")]),t._v(" "),a("h2",{attrs:{id:"通用的约定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通用的约定"}},[t._v("#")]),t._v(" 通用的约定")]),t._v(" "),a("p",[t._v("驼峰法命名")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html#//apple_ref/doc/uid/20000994-BAJHFBGH",target:"_blank",rel:"noopener noreferrer"}},[t._v("内存管理规则:"),a("OutboundLink")],1)]),t._v(" "),a("blockquote",[a("p",[t._v("You create an object using a method whose name begins with “alloc”, “new”, “copy”, or “mutableCopy” (for example, alloc, newObject, or mutableCopy).")])]),t._v(" "),a("h2",{attrs:{id:"常量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常量"}},[t._v("#")]),t._v(" 常量")]),t._v(" "),a("p",[t._v("驼峰法，类名做前缀，尽量用常量类型少用宏")]),t._v(" "),a("h2",{attrs:{id:"方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[t._v("#")]),t._v(" 方法")]),t._v(" "),a("ul",[a("li",[t._v("方法名与方法类型 (-/+ 符号)之间应该以空格间隔")]),t._v(" "),a("li",[t._v("方法段之间也应该以空格间隔（以符合 Apple 风格）")]),t._v(" "),a("li",[t._v('参数前应该总是有一个描述性的关键词。尽可能少用 "and" 这个词')])]),t._v(" "),a("h2",{attrs:{id:"字面值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字面值"}},[t._v("#")]),t._v(" 字面值")]),t._v(" "),a("p",[t._v("不推荐"),a("code",[t._v("[@[] mutableCopy]")]),t._v("这种写法。")]),t._v(" "),a("h1",{attrs:{id:"类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[t._v("#")]),t._v(" 类")]),t._v(" "),a("h2",{attrs:{id:"类名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类名"}},[t._v("#")]),t._v(" 类名")]),t._v(" "),a("ul",[a("li",[t._v("类名应该以三个大写字母作为前缀")]),t._v(" "),a("li",[t._v("当你创建一个子类的时候，你应该把说明性的部分放在前缀和父类名的在中间。如有一个 "),a("code",[t._v("ZOCNetworkClient")]),t._v(" 类，子类的名字会是"),a("code",[t._v("ZOCTwitterNetworkClient")])])]),t._v(" "),a("h2",{attrs:{id:"initializer-和-dealloc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#initializer-和-dealloc"}},[t._v("#")]),t._v(" Initializer 和 dealloc")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("dealloc")]),t._v("函数应该放在文件的最前面，"),a("code",[t._v("init")]),t._v("方法跟在后面。")]),t._v(" "),a("li",[a("code",[t._v("alloc")]),t._v("和"),a("code",[t._v("init")]),t._v("方法解释。")])]),t._v(" "),a("h2",{attrs:{id:"designated-和-secondary-初始化方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#designated-和-secondary-初始化方法"}},[t._v("#")]),t._v(" Designated 和 Secondary 初始化方法")]),t._v(" "),a("ul",[a("li",[t._v("一个类应该有且只有一个 designated 初始化方法")]),t._v(" "),a("li",[t._v("子类的"),a("strong",[t._v("Designated Initializer")]),t._v("应该调用父类的"),a("strong",[t._v("Designated Initializer")]),t._v("方法。")]),t._v(" "),a("li",[t._v("用"),a("code",[t._v("NS_DESIGNATED_INITIALIZER")]),t._v("来指定为Designated Initializer（方法后加上该宏）。")]),t._v(" "),a("li",[a("strong",[t._v("Secondary Initializer")]),t._v("应该调用"),a("strong",[t._v("Designated Initializer")])]),t._v(" "),a("li",[t._v("初始化方法返回参数用"),a("strong",[t._v("instancetype")]),t._v("替换"),a("strong",[t._v("id")])]),t._v(" "),a("li",[t._v("类簇 （class cluster)的解释")]),t._v(" "),a("li",[t._v("单例用"),a("code",[t._v("dispatch_once()")]),t._v("替代"),a("code",[t._v("@synchronized")])])]),t._v(" "),a("h2",{attrs:{id:"属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性"}},[t._v("#")]),t._v(" 属性")]),t._v(" "),a("ul",[a("li",[t._v("命名用小写字母开头的驼峰命名")]),t._v(" "),a("li",[t._v("在init方法里要直接用实例变量，不要用set/get方法访问属性变量。因为子类可能重载属性变量。")]),t._v(" "),a("li",[t._v("用点语法")]),t._v(" "),a("li",[t._v("属性的参数应该按照下面的顺序排列： "),a("strong",[t._v("原子性，读写 和 内存管理")])]),t._v(" "),a("li",[a("strong",[t._v("NSString,NSArray,NSURLRequest")]),t._v("等有可变对象的类，尽量用copy，防止用strong指向可变子类，导致值被修改出现问题")]),t._v(" "),a("li",[t._v("用懒加载（Lazy Loading）时，注意副作用，如get方法里修改了一些类的全局变量，导致加载时机不同出现问题")])]),t._v(" "),a("h2",{attrs:{id:"方法-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法-2"}},[t._v("#")]),t._v(" 方法")]),t._v(" "),a("ul",[a("li",[t._v("用断言"),a("code",[t._v("NSAssert()")]),t._v("或"),a("code",[t._v("NSParameterAssert()")]),t._v("抛参数异常")]),t._v(" "),a("li",[t._v("私有变量和私有方法不要用"),a("code",[t._v("_")]),t._v("前缀，苹果已保留该前缀")])]),t._v(" "),a("h2",{attrs:{id:"相等性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相等性"}},[t._v("#")]),t._v(" 相等性")]),t._v(" "),a("blockquote",[a("p",[t._v("当你要实现相等性的时候记住这个约定：你需要同时实现isEqual 和 hash方法。如果两个对象是被isEqual认为相等的，它们的 hash 方法需要返回一样的值。但是如果 hash 返回一样的值，并不能确保他们相等。")])]),t._v(" "),a("h1",{attrs:{id:"categories"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#categories"}},[t._v("#")]),t._v(" Categories")]),t._v(" "),a("p",[t._v("category里的方法应该用自己的小写前缀加下划线，如"),a("code",[t._v("- (id)zoc_myCategoryMethod")])]),t._v(" "),a("h1",{attrs:{id:"protocols"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#protocols"}},[t._v("#")]),t._v(" Protocols")]),t._v(" "),a("p",[t._v("用协议提高代码的复用性")]),t._v(" "),a("h1",{attrs:{id:"nsnotification"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nsnotification"}},[t._v("#")]),t._v(" NSNotification")]),t._v(" "),a("p",[t._v('通知名应该用类名做前缀，用一个 Did/Will 这样的动词以及用 "Notifications" 后缀。如')]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('// Foo.h\nextern NSString * const ZOCFooDidBecomeBarNotification\n\n// Foo.m\nNSString * const ZOCFooDidBecomeBarNotification = @"ZOCFooDidBecomeBarNotification";\n')])])]),a("h1",{attrs:{id:"美化代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#美化代码"}},[t._v("#")]),t._v(" 美化代码")]),t._v(" "),a("ul",[a("li",[t._v("空格，"),a("strong",[t._v("这里说用四个空格替代TAB，但是一般文章都是推荐用TAB，因为可以根据编译的设定而改变，所以这里存疑")])]),t._v(" "),a("li",[t._v("方法的大括号和其他的大括号(if/else/switch/while 等) 总是在同一行开始")]),t._v(" "),a("li",[t._v("方法之间要有空行")]),t._v(" "),a("li",[t._v("参数换行")])]),t._v(" "),a("h1",{attrs:{id:"代码组织"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码组织"}},[t._v("#")]),t._v(" 代码组织")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("善用代码块"),a("code",[t._v("{}")])])]),t._v(" "),a("li",[a("p",[t._v("方法用"),a("code",[t._v("#pragma mark -")]),t._v("组织分离")])]),t._v(" "),a("li",[a("p",[t._v("当用"),a("code",[t._v("performSelector")]),t._v("调用方法在ARC出现警告时，可用"),a("code",[t._v("#pragma clang diagnostic")]),t._v("去除警告，代码示例：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('  #pragma clang diagnostic push\n  #pragma clang diagnostic ignored "-Warc-performSelector-leaks"\n  \n  [myObj performSelector:mySelector withObject:name];\n  \n  #pragma clang diagnostic pop\n')])])])]),t._v(" "),a("li",[a("p",[t._v("忽视未读变量的方法："),a("code",[t._v("#pragma unused (foo)")]),t._v("（如果foo变量未使用，用该方法不提示警告）")])]),t._v(" "),a("li",[a("p",[t._v("注释分两种"),a("code",[t._v("//")]),t._v("和"),a("code",[t._v("/** */")]),t._v("。"),a("strong",[t._v("非公开、很短、显而易见")]),t._v("的函数一般用"),a("code",[t._v("//")]),t._v(",其它和对外暴露的一般用"),a("code",[t._v("/** */")])])])]),t._v(" "),a("h1",{attrs:{id:"对象间的通讯"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象间的通讯"}},[t._v("#")]),t._v(" 对象间的通讯")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Block，这里说下***“在 block 外定义一个 __weak 的 引用到 self，并在 block 内部通过这个弱引用定义一个 __strong 的引用。”***的情况。这种一般是需要持有self，但是又为了避免retain circle的情况。block内的self强引用是Block执行时创建的，\n示例代码如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('  @property (nonatomic,strong) NSString *testString;\n  @property (nonatomic,copy) void(^BlockTest)();\n\n\n  self.testString = @"testststs";\n  __weak typeof(self)weakSelf = self;\n  self.BlockTest = ^(){\n      __strong typeof(self)strongSelf = weakSelf;\n      NSLog(@"%@",strongSelf.testString);\n  };\n  \n  self.BlockTest();\n')])])])])]),t._v(" "),a("p",[t._v("注：weakSelf是为了block不持有self，避免循环引用，而再声明一个strongSelf是因为一旦进入block执行，就不允许self在这个执行过程中释放。block执行完后这个strongSelf会自动释放，没有循环引用问题。")]),t._v(" "),a("ul",[a("li",[t._v("多重委托")])]),t._v(" "),a("h1",{attrs:{id:"面向切面编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向切面编程"}},[t._v("#")]),t._v(" 面向切面编程")]),t._v(" "),a("p",[t._v("AOP，面向切面编程，统计与日志就是一个完美的例子。")])])}),[],!1,null,null,null);a.default=s.exports}}]);